项目：理论上，所有的项目，都是自己定义好一些功能，或者调用一些别人已经实现的功能，构成依赖，在main函数（库）中调用这些依赖，构成一个可执行程序（新的库）。
      那么项目管理文件，其实就是在管理这些依赖，让main函数（新的库）所在的cpp文件，能够找到这些依赖的定义声明(头文件.h)，实现的源文件(cpp文件)，已经编译好的二进制库文件(动态库.so和.dll ， 
      静态库.a 和 .lib)，最终把这些功能组装或者链接成一个可执行的exe程序（新的库）
      
      指明main函数的头文件和实现文件(库文件)所在的地方，也就是依赖的路径，叫做项目管理，项目管理文件有cmake的CMakeLists.txt，make的makefile，qt的.pro，visual studio的.sln。这些项目管理文件，职责都是
      协助找到头文件和实现文件(库文件)，然后定义一些编译参数变量，调用编译器（windows常用的编译器是visual studio的msvc，MinGW64; Linux常用的编译器是gcc，g++)，最终编译生成一个可执行程序，或者一个库文件
     （动态库或者静态库）

      编译的过程中，一般的步骤是，先将#include进行复制替换，就相当于把cpp中#include那一行，替换成被包含的那个头文件的所有内容
                                然后将每个cpp编译成一个独立的二进制目标文件，这个二进制文件中有，全局唯一的全局变量身份识别，全局唯一的函数接口身份识别（这就说明模板类的函数实现是不能放在
                                独立的cpp中，因为模板参数值没定，函数的唯一身份识别就也没有定，调用连接时就找不到。模板类的实现函数，必须和模板类使用实例对象，在同一个cpp中，或者在h中，被这个cpp包含，
                                在编译前，根据模板类的实例对象的需求，C++编译器先将模板参数替换具体类型，动态生成所需要的模板类，生成和编译对应的模板类型的函数，明确全局唯一的函数接口身份识别）
                                每个cpp编译成了二进制文件，在该项目的所有cpp编译成的二进制文件中，所有的变量和函数都有唯一的身份识别。
                                最后一步就是链接，根据main函数（新的库）中调用的函数和变量，去所有的二进制文件中找，找不到就会报错。

函数：函数身份由4个因素唯一的确定，  返回类型 名空间::函数名(形参类型)
     没有指定名空间，就是全局名空间

总的一句：项目管理就是依赖管理，就是声明（头文件）和实现（库文件）的管理。做好这两步，一个可执行程序或者一个新的库就可以生成了。
         在cmake的语法中分别是
         include_directories(./include)          //找到头文件
         add_executable(${PROJECT_NAME} ./src/list.cpp ./src/test.cpp)     //编译挑选好的cpp
         target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS})             //去找别人提供的库中的函数，确认自己调用无误
