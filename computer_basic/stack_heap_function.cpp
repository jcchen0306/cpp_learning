#include<stdio.h>
//所有函数被调用的时候，函数形参分三种情况：1）某一种变量类型； 2）某一种变量类型的指针变量；3）某一种变量类型的引用（C++才有的）
//1)形参为某一种变量的时候，掉用进入到被调函数那一刻，就开始为形参在栈上面申请内存。然后调用时为形参输入的值，会被赋给前面调用过程中申请的那个变量。这个变量和调用函数的变量完全无关。
//2)形参为某一变量类型指针的时候，原理同上，进入被调函数那一刻，就开始为形参类型指针申请一个内存。然后这个内存里保存的是传进来的指针变量的值，也就是指向某一个变量的地址。
//  这种情况下在子函数内部，多了一种赋值情况： 对指针指向的地址进行赋值（指针间接寻址运算写操作）； 对指针变量赋值（类似于1）   
//3)形参为某一种变量类型的引用（C++才有的）,进入被调函数那一刻,没有申请任何内存。相当于形参接受的变量的信息，完全等价于形参变量在子函数中的信息。引用的符号是&， 函数写法是 int func(int& a);
//  调用这个函数时,例如在调用函数中定义了int b； 然后调用func，写法是func（b），这个时候，不为 int& a 申请内存，只是b的身份完全被给了a，也就是子函数中所有的a都被换成了b。
//  和前面两条的区别就是，引用是不申请内存，直接对传经来的变量操作。

//总结： 1）中子函数无法更改父函数中传进来的变量的值； 2）可以通过指针间址运算写操作修改； 3）所有的写操作都会修改父函数中传进来的变量的值。
//      1）最简单，但是功能有限 ； 2) 功能多，但是指针要求高（指针两种赋值情况） ； 3）功能唯一，最省内存。

int change(int p)  
{
    p=101;
    printf("p的内存地址是%p\n",&p);
    printf("p的值是%p\n",p);
    return p+1;
}

int main()
{
    int a;
    int b;
    a=1;
    printf("a的内存地址是%p\n",&a);
    printf("b的内存地址是%p\n",&b);
    b=change(a);
    printf("a 的值是%d\n",a);
    printf("b 的值是%d\n",b);
}




int change(int* p)
{
    *p=101;
    printf("p的值是%p\n",p);
    printf("p的内存地址是%p\n",&p);
    printf("*p的值是%d\n",*p);
    return p;
}

int main()
{
    int a;
    int* b;
    a=1;
    printf("a的内存地址是%p\n",&a);
    printf("b的内存地址是%p\n",&b);
    b=change(&a);
    printf("a 的值是%d\n",a);
    printf("b 的值是%p\n",b);
    printf("*b 的值是%d\n",*b);
}




堆：用malloc申请的内存。作用域：全局可用。 生命周期：直到free
栈：其他非malloc申请的内存，作用域：局部可用 可以是一个函数也可以是{}以内的。生命周期：出了局部代码块就消失了

所以，变量最重要的3个概念： 一，内存空间的问题；二，作用域的问题；三，生命周期的问题。（和堆栈的概念相关，堆和栈的大小都是有限制的）

电影文件放硬盘；编程的变量才是在内存。


